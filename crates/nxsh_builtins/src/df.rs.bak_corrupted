//! df command - report filesystem disk space usage.
//! Usage: df [-h] [PATH]
//!   -h : human readable sizes
//! If PATH omitted, uses current directory.

use anyhow::{anyhow, Result};
use std::path::Path;
use crate::ui_design::{Colorize};

#[cfg(windows)]
use std::ffi::OsStr;
#[cfg(windows)]
use std::os::windows::ffi::OsStrExt;
#[cfg(windows)]
use winapi::um::fileapi::GetDiskFreeSpaceExW;
#[cfg(windows)]


#[cfg(unix)]
use std::os::unix::fs::MetadataExt;

/// Display filesystem information
pub fn main(args: Vec<String>) -> Result<()> {
    df_cli(&args)
}

pub fn df_cli(args: &[String]) -> Result<()> {
    let human_readable = args.contains(&"-h".to_string());
    
    let path = if args.len() > 1 && !args[1].starts_with('-') {
        &args[1]
    } else {
        "."
    };

    show_disk_space(path, human_readable)
}

fn show_disk_space(path: &str, human_readable: bool) -> Result<()> {
    let path = Path::new(path);
    
    if !path.exists() {
        return Err(anyhow!("Path does not exist: {}", path.display()));
    }

    let formatter = TableFormatter::new();
    
    #[cfg(windows)]
    let (total, free, available) = get_disk_space_windows(path)?;
    
    #[cfg(unix)]
    let (total, free, available) = get_disk_space_unix(path)?;
    
    let used = total - free;
    let use_percent = if total > 0 {
        (used as f64 / total as f64 * 100.0) as u64
    } else {
        0
    };

    let headers = vec!["Filesystem", "Size", "Used", "Available", "Use%", "Mounted on"];
    
    let size_formatter = if human_readable {
        |bytes: u64| format_human_readable(bytes)
    } else {
        |bytes: u64| bytes.to_string()
    };
    
    let filesystem = if cfg!(windows) {
        get_filesystem_name_windows(path).unwrap_or_else(|| "NTFS".to_string())
    } else {
        get_filesystem_name_windows(path).unwrap_or_else(|| "Unknown".to_string())
    };
    
    let row = vec![
        filesystem,
        size_formatter(total),
        size_formatter(used),
        size_formatter(available),
        format!("{}%", use_percent),
        path.display().to_string(),
    ];
    
    let table = formatter.create_table(&headers, &[row]);
    print!("{}", table);
    
    Ok(())
}

#[cfg(windows)]
fn get_disk_space_windows(path: &Path) -> Result<(u64, u64, u64)> {

    
    let path_wide: Vec<u16> = OsStr::new(path)
        .encode_wide()
        .chain(std::iter::once(0))
        .collect();
    
    use winapi::shared::ntdef::ULARGE_INTEGER;
    
    let mut free_bytes = ULARGE_INTEGER::default();
    let mut total_bytes = ULARGE_INTEGER::default();
    let mut total_free = ULARGE_INTEGER::default();
    
    unsafe {
        let result = GetDiskFreeSpaceExW(
            path_wide.as_ptr(),
            &mut free_bytes,
            &mut total_bytes,
            &mut total_free,
        );
        
        if result == 0 {
            return Err(anyhow!("Failed to get disk space information"));
        }
        
        // Convert to u64 values
        let free_bytes_val = *free_bytes.QuadPart() as u64;
        let total_bytes_val = *total_bytes.QuadPart() as u64;
        let total_free_val = *total_free.QuadPart() as u64;
        
        return Ok((total_bytes_val, total_free_val, free_bytes_val));
    }
    
    // 縺薙・髢｢謨ｰ縺ｯ蛻ｰ驕斐＠縺ｪ縺・・縺壹〒縺・
    Err(anyhow!("Unsupported platform"))
}

#[cfg(unix)]
fn get_disk_space_unix(path: &Path) -> Result<(u64, u64, u64)> {
    use std::fs;
    use std::mem;
    use std::os::raw::{c_char, c_int, c_ulong};
    
    #[repr(C)]
    struct Statvfs {
        f_bsize: c_ulong,
        f_frsize: c_ulong,
        f_blocks: u64,
        f_bfree: u64,
        f_bavail: u64,
        f_files: u64,
        f_ffree: u64,
        f_favail: u64,
        f_fsid: c_ulong,
        f_flag: c_ulong,
        f_namemax: c_ulong,
    }
    
    extern "C" {
        fn statvfs(path: *const c_char, buf: *mut Statvfs) -> c_int;
    }
    
    let path_cstring = CString::new(path.to_string_lossy().as_ref())?;
    let mut stat: Statvfs = unsafe { mem::zeroed() };
    
    let result = unsafe {
        statvfs(path_cstring.as_ptr(), &mut stat as *mut Statvfs)
    };
    
    if result != 0 {
        return Err(anyhow!("Failed to get filesystem statistics"));
    }
    
    let block_size = stat.f_frsize;
    let total = stat.f_blocks * block_size;
    let free = stat.f_bfree * block_size;
    let available = stat.f_bavail * block_size;
    
    Ok((total, free, available))
}

#[cfg(unix)]
fn get_filesystem_name_unix(_path: &Path) -> Option<String> {
    // This would require parsing /proc/mounts or similar
    // For now, return a generic name
    Some("filesystem".to_string())
}

#[cfg(windows)]
fn get_filesystem_name_windows(_path: &Path) -> Option<String> {
    // For now, just return NTFS as it's most common on Windows
    Some("NTFS".to_string())
}

#[cfg(unix)]
fn get_filesystem_name_unix(_path: &Path) -> Option<String> {
    // This would require parsing /proc/mounts or similar
    // For now, return a generic name
    Some("filesystem".to_string())
}

fn format_human_readable(bytes: u64) -> String {
    const UNITS: &[&str] = &["B", "K", "M", "G", "T", "P"];
    let mut size = bytes as f64;
    let mut unit_index = 0;
    
    while size >= 1024.0 && unit_index < UNITS.len() - 1 {
        size /= 1024.0;
        unit_index += 1;
    }
    
    if unit_index == 0 {
        format!("{}", bytes)
    } else {
        format!("{:.1}{}", size, UNITS[unit_index])
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_format_human_readable() {
        assert_eq!(format_human_readable(0), "0");
        assert_eq!(format_human_readable(1023), "1023");
        assert_eq!(format_human_readable(1024), "1.0K");
        assert_eq!(format_human_readable(1536), "1.5K");
        assert_eq!(format_human_readable(1048576), "1.0M");
    }
    
    #[test]
    fn test_show_disk_space_current_dir() {
        // Test with current directory - should not panic
        let result = show_disk_space(".", false);
        assert!(result.is_ok());
    }
}



