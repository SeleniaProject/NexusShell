//! `du` command  Eestimate file space usage.
//! Usage: du [-h] [PATH]
//!   -h : human readable units
//! If PATH omitted, uses current directory.

use anyhow::Result;
use walkdir::WalkDir;
use std::path::Path;
#[cfg(feature = "async-runtime")]
use tokio::task;

// Beautiful CUI design
use crate::ui_design::{ColorPalette, Icons, Colorize};

#[cfg(not(feature = "async-runtime"))]
pub fn du_cli(args: &[String]) -> Result<()> {
    let mut human = false;
    let mut path = ".".to_string();
    for arg in args {
        if arg == "-h" { human = true; continue; }
        path = arg.clone();
    }
    
    let colors = ColorPalette::new();
    let icons = Icons::new(true);
    
    // Beautiful header
    println!("\n{}{}┌─── {} Disk Usage Analysis for {} ───┐{}", 
        colors.primary, "╁E.repeat(5), icons.folder, path.bright_cyan(), colors.reset);
    
    let size = calc_size(Path::new(&path).to_path_buf())?;
    let human_size = bytesize::ByteSize::b(size).to_string_as(true);
    
    // Beautiful table output
    let table = TableFormatter::new(true);
    let mut rows = vec![
        vec!["Path".to_string(), "Size".to_string(), "Type".to_string()],
        vec![
            path.bright_yellow().to_string(),
            if human { human_size.bright_green().to_string() } else { size.to_string().bright_green().to_string() },
            "Directory".bright_blue().to_string()
        ]
    ];
    
    table.print_table(&rows, &["Path", "Size", "Type"]);
    Ok(())
}

#[cfg(feature = "async-runtime")]
pub async fn du_cli(args: &[String]) -> Result<()> {
    let mut human = false;
    let mut path = ".".to_string();
    for arg in args {
        if arg == "-h" { human = true; continue; }
        path = arg.clone();
    }
    let p = Path::new(&path).to_path_buf();
    let size = task::spawn_blocking(move || calc_size(p)).await??;
    if human {
        println!("{}", bytesize::ByteSize::b(size).to_string_as(true));
    } else {
        println!("{size}");
    }
    Ok(())
}

fn calc_size(root: std::path::PathBuf) -> Result<u64> {
    let mut total = 0u64;
    for entry in WalkDir::new(root) {
        let e = entry?;
        if e.file_type().is_file() {
            total += e.metadata()?.len();
        }
    }
    Ok(total)
}

#[cfg(test)]
mod tests {
    use super::*;
    use tempfile::tempdir;
    use std::io::Write;
    #[cfg(feature = "async-runtime")]
    #[tokio::test]
    async fn du_basic() {
        let d = tempdir().unwrap();
        let f = d.path().join("a.txt");
        let mut file = std::fs::File::create(&f).unwrap();
        writeln!(file, "hello").unwrap();
        du_cli(&[d.path().to_string_lossy().into()]).await.unwrap();
    }
    #[cfg(not(feature = "async-runtime"))]
    #[test]
    fn du_basic_sync() {
        let d = tempdir().unwrap();
        let f = d.path().join("a.txt");
        let mut file = std::fs::File::create(&f).unwrap();
        writeln!(file, "hello").unwrap();
        du_cli(&[d.path().to_string_lossy().into()]).unwrap();
    }
} 


