// NexusShell Grammar Definition
// Complete PEG grammar for advanced shell parsing with modern features

WHITESPACE = _{ " " | "\t" }
COMMENT = _{ "#" ~ (!"\n" ~ ANY)* }

// Entry point
program = { SOI ~ statement_list? ~ EOI }

statement_list = { statement ~ (statement_separator ~ statement)* ~ statement_separator? }

statement = {
    pipeline |
    command_statement |
    control_structure |
    function_definition |
    variable_assignment |
    alias_definition |
    import_statement
}

statement_separator = {
    ";" |
    "&&" |
    "||" |
    "&" |
    "\n" |
    "\r\n"
}

// Pipeline constructs
pipeline = {
    pipeline_element ~ (pipe_operator ~ pipeline_element)+
}

pipe_operator = {
    "||>" |  // Parallel object pipe
    "|>" |   // Object pipe
    "||" |   // Logical OR
    "|"      // Standard pipe
}

pipeline_element = {
    command_statement |
    subshell |
    process_substitution
}

// Command statements
command_statement = {
    command ~ redirection*
}

command = {
    simple_command |
    compound_command
}

simple_command = {
    command_name ~ argument*
}

compound_command = {
    brace_group |
    arithmetic_expression |
    conditional_expression |
    subshell
}

command_name = {
    word |
    variable_expansion |
    command_substitution |
    pathname_expansion
}

argument = {
    word |
    string_literal |
    variable_expansion |
    command_substitution |
    arithmetic_expansion |
    pathname_expansion |
    process_substitution |
    brace_expansion |
    tilde_expansion
}

// Control structures
control_structure = {
    if_statement |
    for_statement |
    while_statement |
    until_statement |
    case_statement |
    select_statement |
    match_statement |
    try_statement
}

if_statement = {
    "if" ~ condition ~ "then" ~ statement_list ~
    ("elif" ~ condition ~ "then" ~ statement_list)* ~
    ("else" ~ statement_list)? ~
    "fi"
}

for_statement = {
    for_in_statement |
    for_c_statement |
    for_async_statement
}

for_in_statement = {
    "for" ~ identifier ~ "in" ~ word_list ~ "do" ~ statement_list ~ "done"
}

for_c_statement = {
    "for" ~ "((" ~ arithmetic_expression? ~ ";" ~ condition? ~ ";" ~ arithmetic_expression? ~ "))" ~
    "do" ~ statement_list ~ "done"
}

for_async_statement = {
    "for" ~ "async" ~ identifier ~ "in" ~ word_list ~ "do" ~ statement_list ~ "done"
}

while_statement = {
    "while" ~ condition ~ "do" ~ statement_list ~ "done"
}

until_statement = {
    "until" ~ condition ~ "do" ~ statement_list ~ "done"
}

case_statement = {
    "case" ~ word ~ "in" ~ case_item* ~ "esac"
}

case_item = {
    pattern_list ~ ")" ~ statement_list ~ ";;"
}

select_statement = {
    "select" ~ identifier ~ ("in" ~ word_list)? ~ "do" ~ statement_list ~ "done"
}

// Modern control structures
match_statement = {
    "match" ~ expression ~ "{" ~ match_arm* ~ "}"
}

match_arm = {
    pattern ~ ("if" ~ condition)? ~ "=>" ~ statement_list
}

try_statement = {
    "try" ~ "{" ~ statement_list ~ "}" ~
    ("catch" ~ identifier? ~ "{" ~ statement_list ~ "}")? ~
    ("finally" ~ "{" ~ statement_list ~ "}")?
}

// Function definitions
function_definition = {
    function_declaration |
    function_assignment
}

function_declaration = {
    "function" ~ identifier ~ "()" ~ compound_command
}

function_assignment = {
    identifier ~ "()" ~ compound_command
}

// Variable assignments
variable_assignment = {
    assignment_word ~ assignment_operator ~ assignment_value
}

assignment_operator = {
    "+=" |
    "-=" |
    "*=" |
    "/=" |
    "%=" |
    "="
}

assignment_value = {
    array_assignment |
    word |
    string_literal |
    arithmetic_expansion |
    command_substitution |
    variable_expansion
}

array_assignment = {
    "(" ~ array_element* ~ ")"
}

array_element = {
    ("[" ~ word ~ "]" ~ "=")? ~ word
}

// Alias definitions
alias_definition = {
    "alias" ~ identifier ~ "=" ~ string_literal
}

// Import statements (modern feature)
import_statement = {
    import_use |
    import_from |
    import_mod
}

import_use = {
    "use" ~ module_path ~ ("as" ~ identifier)?
}

import_from = {
    "from" ~ module_path ~ "import" ~ import_list
}

import_mod = {
    "mod" ~ identifier ~ "{" ~ statement_list ~ "}"
}

module_path = {
    identifier ~ ("::" ~ identifier)*
}

import_list = {
    identifier ~ ("," ~ identifier)* |
    "*"
}

// Expressions
condition = {
    logical_or_expression
}

logical_or_expression = {
    logical_and_expression ~ ("||" ~ logical_and_expression)*
}

logical_and_expression = {
    equality_expression ~ ("&&" ~ equality_expression)*
}

equality_expression = {
    relational_expression ~ (("==" | "!=" | "=~" | "!~") ~ relational_expression)*
}

relational_expression = {
    arithmetic_expression ~ (("<=" | ">=" | "<" | ">") ~ arithmetic_expression)*
}

arithmetic_expression = {
    term ~ (("+" | "-") ~ term)*
}

term = {
    factor ~ (("*" | "/" | "%") ~ factor)*
}

factor = {
    power ~ ("**" ~ power)*
}

power = {
    unary_expression
}

unary_expression = {
    ("!" | "-" | "+") ~ unary_expression |
    postfix_expression
}

postfix_expression = {
    primary_expression ~ ("++" | "--")?
}

primary_expression = {
    "(" ~ logical_or_expression ~ ")" |
    test_expression |
    arithmetic_expansion |
    variable_expansion |
    command_substitution |
    word |
    number
}

test_expression = {
    "[" ~ test_condition ~ "]" |
    "[[" ~ test_condition ~ "]]" |
    "test" ~ test_arguments
}

test_condition = {
    test_binary |
    test_unary |
    test_primary
}

test_binary = {
    test_primary ~ test_binary_operator ~ test_primary
}

test_unary = {
    test_unary_operator ~ test_primary
}

test_primary = {
    word |
    string_literal |
    variable_expansion |
    command_substitution
}

test_binary_operator = {
    "-eq" | "-ne" | "-lt" | "-le" | "-gt" | "-ge" |
    "-ef" | "-nt" | "-ot" |
    "=" | "!=" | "<" | ">" |
    "=~" | "!~"
}

test_unary_operator = {
    "-a" | "-b" | "-c" | "-d" | "-e" | "-f" | "-g" | "-h" | "-k" |
    "-p" | "-r" | "-s" | "-t" | "-u" | "-w" | "-x" | "-O" | "-G" |
    "-L" | "-N" | "-S" | "-z" | "-n"
}

test_arguments = {
    argument+
}

// Expansions
variable_expansion = {
    simple_variable |
    parameter_expansion |
    positional_parameter |
    special_parameter
}

simple_variable = {
    "$" ~ identifier
}

parameter_expansion = {
    "${" ~ parameter_expansion_body ~ "}"
}

parameter_expansion_body = {
    identifier ~ parameter_modifier?
}

parameter_modifier = {
    ":-" ~ word |
    ":=" ~ word |
    ":?" ~ word? |
    ":+" ~ word |
    ":" ~ arithmetic_expression ~ (":" ~ arithmetic_expression)? |
    "#" ~ pattern |
    "##" ~ pattern |
    "%" ~ pattern |
    "%%" ~ pattern |
    "/" ~ pattern ~ ("/" ~ word)? |
    "//" ~ pattern ~ ("/" ~ word)? |
    "^" ~ pattern |
    "^^" ~ pattern |
    "," ~ pattern |
    ",," ~ pattern
}

positional_parameter = {
    "$" ~ ASCII_DIGIT+
}

special_parameter = {
    "$" ~ ("@" | "*" | "#" | "?" | "-" | "$" | "!" | "0" | "_")
}

command_substitution = {
    "$(" ~ statement_list ~ ")" |
    "`" ~ (!"`" ~ ANY)* ~ "`"
}

arithmetic_expansion = {
    "$((" ~ arithmetic_expression ~ "))" |
    "$[" ~ arithmetic_expression ~ "]"
}

process_substitution = {
    "<(" ~ statement_list ~ ")" |
    ">(" ~ statement_list ~ ")"
}

pathname_expansion = {
    glob_pattern
}

glob_pattern = {
    glob_element+
}

glob_element = {
    "*" |
    "?" |
    "[" ~ character_class ~ "]" |
    "{" ~ brace_list ~ "}" |
    glob_char
}

character_class = {
    "!" ~ character_range+ |
    character_range+
}

character_range = {
    ASCII_ALPHANUMERIC ~ "-" ~ ASCII_ALPHANUMERIC |
    ASCII_ALPHANUMERIC
}

brace_expansion = {
    "{" ~ brace_list ~ "}"
}

brace_list = {
    brace_element ~ ("," ~ brace_element)+
}

brace_element = {
    word |
    number ~ ".." ~ number
}

tilde_expansion = {
    "~" ~ identifier?
}

// Redirections
redirection = {
    io_redirect |
    here_document |
    here_string
}

io_redirect = {
    io_number? ~ redirection_operator ~ redirection_target
}

io_number = {
    ASCII_DIGIT+
}

redirection_operator = {
    ">>" |
    ">&" |
    "&>" |
    "&>>" |
    "<&" |
    ">" |
    "<"
}

redirection_target = {
    word |
    "&" ~ io_number |
    "&-"
}

here_document = {
    "<<" ~ here_doc_delimiter ~ "\n" ~ here_doc_content ~ here_doc_delimiter
}

here_string = {
    "<<<" ~ word
}

here_doc_delimiter = {
    word
}

here_doc_content = {
    (!here_doc_delimiter ~ ANY)*
}

// Compound commands
brace_group = {
    "{" ~ statement_list ~ "}"
}

subshell = {
    "(" ~ statement_list ~ ")"
}

conditional_expression = {
    "[[" ~ logical_or_expression ~ "]]"
}

// Patterns
pattern = {
    pattern_element+
}

pattern_element = {
    "*" |
    "?" |
    "[" ~ character_class ~ "]" |
    "\\" ~ ANY |
    pattern_char
}

pattern_list = {
    pattern ~ ("|" ~ pattern)*
}

// Literals and identifiers
word = {
    word_element+
}

word_element = {
    quoted_string |
    variable_expansion |
    command_substitution |
    arithmetic_expansion |
    pathname_expansion |
    brace_expansion |
    tilde_expansion |
    word_char
}

string_literal = {
    double_quoted_string |
    single_quoted_string |
    ansi_c_quoted_string
}

double_quoted_string = {
    "\"" ~ double_quoted_content* ~ "\""
}

double_quoted_content = {
    variable_expansion |
    command_substitution |
    arithmetic_expansion |
    escape_sequence |
    double_quoted_char
}

single_quoted_string = {
    "'" ~ single_quoted_content* ~ "'"
}

single_quoted_content = {
    single_quoted_char
}

ansi_c_quoted_string = {
    "$'" ~ ansi_c_content* ~ "'"
}

ansi_c_content = {
    ansi_c_escape |
    ansi_c_char
}

ansi_c_escape = {
    "\\" ~ ("a" | "b" | "e" | "E" | "f" | "n" | "r" | "t" | "v" | "\\" | "'" | "\"" | "?" |
            ASCII_DIGIT{1,3} | "x" ~ ASCII_HEX_DIGIT{1,2} | "u" ~ ASCII_HEX_DIGIT{4} | "U" ~ ASCII_HEX_DIGIT{8})
}

quoted_string = {
    double_quoted_string |
    single_quoted_string |
    ansi_c_quoted_string
}

escape_sequence = {
    "\\" ~ ANY
}

number = {
    ("0x" ~ ASCII_HEX_DIGIT+) |
    ("0" ~ ASCII_OCT_DIGIT+) |
    (ASCII_DIGIT+ ~ ("." ~ ASCII_DIGIT+)?) |
    ("." ~ ASCII_DIGIT+)
}

identifier = {
    (ASCII_ALPHA | "_") ~ (ASCII_ALPHANUMERIC | "_")*
}

assignment_word = {
    identifier ~ ("[" ~ word ~ "]")?
}

word_list = {
    word+
}

// Character classes
word_char = {
    !(" " | "\t" | "\n" | "\r" | ";" | "&" | "|" | "(" | ")" | "{" | "}" | 
      "<" | ">" | "\"" | "'" | "\\" | "$" | "`" | "*" | "?" | "[" | "]" | "#") ~ ANY
}

double_quoted_char = {
    !("\"" | "\\" | "$" | "`") ~ ANY
}

single_quoted_char = {
    !"'" ~ ANY
}

ansi_c_char = {
    !("'" | "\\") ~ ANY
}

glob_char = {
    !("*" | "?" | "[" | "{" | " " | "\t" | "\n" | "\r" | ";" | "&" | "|" | 
      "(" | ")" | "<" | ">" | "\"" | "'") ~ ANY
}

pattern_char = {
    !("*" | "?" | "[" | "|" | ")" | " " | "\t" | "\n" | "\r") ~ ANY
}

// Keywords (for context-sensitive parsing)
keyword = {
    "if" | "then" | "else" | "elif" | "fi" |
    "for" | "while" | "until" | "do" | "done" |
    "case" | "esac" | "in" | "select" |
    "function" | "return" | "break" | "continue" |
    "local" | "export" | "readonly" | "declare" | "typeset" |
    "let" | "eval" | "exec" | "source" | "." |
    "alias" | "unalias" | "set" | "unset" | "shift" |
    "getopts" | "read" | "echo" | "printf" | "test" |
    "trap" | "kill" | "jobs" | "bg" | "fg" | "wait" |
    "suspend" | "times" | "type" | "which" | "command" |
    "builtin" | "enable" | "help" | "history" | "fc" |
    "dirs" | "pushd" | "popd" | "cd" | "pwd" | "exit" | "logout" |
    "match" | "with" | "try" | "catch" | "finally" | "throw" |
    "async" | "await" | "yield" | "import" | "from" | "as" |
    "use" | "mod" | "pub" | "struct" | "enum" | "trait" |
    "impl" | "where" | "const" | "static" | "mut" | "ref" |
    "move" | "self" | "Self" | "super" | "crate"
} 