// NexusShell Grammar Definition
// This grammar defines the complete syntax of NexusShell including advanced features

WHITESPACE = _{ " " | "\t" }
COMMENT = _{ "#" ~ (!"\n" ~ ANY)* }

// Keywords - MUST be defined before identifiers to ensure correct precedence
if_kw = @{ "if" ~ !ASCII_ALPHANUMERIC }
then_kw = @{ "then" ~ !ASCII_ALPHANUMERIC }
else_kw = @{ "else" ~ !ASCII_ALPHANUMERIC }
elif_kw = @{ "elif" ~ !ASCII_ALPHANUMERIC }
fi_kw = @{ "fi" ~ !ASCII_ALPHANUMERIC }
for_kw = @{ "for" ~ !ASCII_ALPHANUMERIC }
while_kw = @{ "while" ~ !ASCII_ALPHANUMERIC }
do_kw = @{ "do" ~ !ASCII_ALPHANUMERIC }
done_kw = @{ "done" ~ !ASCII_ALPHANUMERIC }
case_kw = @{ "case" ~ !ASCII_ALPHANUMERIC }
esac_kw = @{ "esac" ~ !ASCII_ALPHANUMERIC }
function_kw = @{ "function" ~ !ASCII_ALPHANUMERIC }
match_kw = @{ "match" ~ !ASCII_ALPHANUMERIC }
with_kw = @{ "with" ~ !ASCII_ALPHANUMERIC }
in_kw = @{ "in" ~ !ASCII_ALPHANUMERIC }
select_kw = @{ "select" ~ !ASCII_ALPHANUMERIC }

// Basic tokens - identifiers must NOT match keywords
identifier = @{ !KEYWORD ~ (ASCII_ALPHA | "_" | "-" | "/" | ".") ~ (ASCII_ALPHANUMERIC | "_" | "." | "/" | "-")* }
KEYWORD = { if_kw | then_kw | else_kw | elif_kw | fi_kw | for_kw | while_kw | do_kw | done_kw | case_kw | esac_kw | function_kw | match_kw | with_kw | in_kw | select_kw }

number = @{ ASCII_DIGIT+ ~ ("." ~ ASCII_DIGIT+)? }
string_literal = @{ "\"" ~ (!"\"" ~ ANY)* ~ "\"" | "'" ~ (!"'" ~ ANY)* ~ "'" }

// Operators
pipe = { "|" }
object_pipe = { "|>" }
parallel_pipe = { "||>" }
redirect_in = { "<" }
redirect_out = { ">" }
redirect_append = { ">>" }
redirect_err = { "2>" }
redirect_both = { "&>" }
background = { "&" }
and_op = { "&&" }
or_op = { "||" }
semicolon = { ";" }

// Keywords (already defined above - remove duplicate definitions)

// Expressions
glob_word = @{ (!WHITESPACE ~ !COMMENT ~ !(";" | "|" | "&&" | "||" | "&" | "(" | ")") ~ ANY)+ }
word = { identifier | string_literal | number | glob_word }
assignment = { identifier ~ "=" ~ assignment_value }
assignment_value = { (!WHITESPACE ~ !COMMENT ~ !semiconductor_char ~ ANY)+ }
semiconductor_char = { "|" | "&" | ";" | "(" | ")" }
simple_word = { identifier }

// Variables
variable = { "$" ~ identifier | "${" ~ identifier ~ "}" }
command_substitution = { "$(" ~ simple_word ~ ")" | "`" ~ simple_word ~ "`" }

argument = { assignment | closure_expr | variable | command_substitution | word }

// Closures (experimental): (param1,param2){ ... }
closure_param_list = { identifier ~ ("," ~ identifier)* }
closure_expr = { "(" ~ closure_param_list? ~ ")" ~ brace_group }

// Commands
redirection = { (redirect_in | redirect_out | redirect_append | redirect_err | redirect_both) ~ word }
// simple_command 拡張: ジェネリクス呼び出し (call_generic_args) を許可
simple_command = { (assignment ~ (WHITESPACE* ~ assignment)*)? ~ word ~ call_generic_args? ~ argument* ~ redirection* }
subshell = { "(" ~ command_list ~ ")" }
command_element = { simple_command | subshell }
pipeline = { command_element ~ (pipe ~ command_element)* }
command = { pipeline | subshell }

// Control structures - Simplified and corrected structure
if_statement = { if_kw ~ test_command ~ then_kw ~ command_list ~ (elif_kw ~ test_command ~ then_kw ~ command_list)* ~ (else_kw ~ command_list)? ~ fi_kw }
for_statement = { for_kw ~ identifier ~ in_kw ~ word_list? ~ line_terminator? ~ do_kw ~ command_list ~ done_kw }
while_statement = { while_kw ~ test_command ~ do_kw ~ command_list ~ done_kw }
case_statement = { case_kw ~ word ~ in_kw ~ case_item* ~ esac_kw }
select_statement = { select_kw ~ identifier ~ (in_kw ~ word_list)? ~ do_kw ~ command_list ~ done_kw }
case_item = { pattern ~ ")" ~ command_list ~ ";;" }
pattern = { word ~ ("|" ~ word)* }

// Helper rules for control structures
test_command = { command ~ semicolon? }
command_list = { (statement ~ line_terminator?)* }
word_list = { word+ }
// Do not consume the first ';' of a ';;' token used by case items
line_terminator = { (semicolon ~ !semicolon) | "\n" }

// Function definition
// Function definition (拡張: ジェネリクス + パラメータ)
function_def = { function_kw ~ identifier ~ generic_params? ~ "(" ~ parameter_list? ~ ")" ~ brace_group }

// Generics & parameters
generic_params = { "<" ~ identifier ~ ("," ~ identifier)* ~ ">" }
parameter_list = { identifier ~ ("," ~ identifier)* }

// Brace group (既存 command_list より高レベル構造用)
brace_group = { "{" ~ statement_list? ~ "}" }

// Match statement (advanced feature)
match_statement = { match_kw ~ argument ~ with_kw ~ match_arm* }
match_arm = { pattern ~ "=>" ~ program }

// Statements - Control structures MUST be checked before simple commands
// Macro + 拡張ステートメント
macro_declaration = { "macro" ~ identifier ~ "(" ~ macro_param_list? ~ ")" ~ brace_group }
macro_param_list = { identifier ~ ("," ~ identifier)* }
macro_invocation = { identifier ~ "!" ~ "(" ~ macro_argument_list? ~ ")" }
macro_argument_list = { (word | string_literal) ~ ("," ~ (word | string_literal))* }

// call site generics for simple command interpreted as function call
call_generic_args = { "<" ~ identifier ~ ("," ~ identifier)* ~ ">" }

statement = {
    closure_expr |
    macro_declaration |
    macro_invocation |
    if_statement |
    for_statement |
    while_statement |
    case_statement |
    select_statement |
    function_def |
    match_statement |
    command
}

// statement_list (ブロック内などで使用)
statement_list = { (statement ~ line_terminator?)* }

// Program structure - Improved to handle control structures properly
line = { statement ~ (and_op ~ statement | or_op ~ statement | semicolon ~ statement)* ~ background? ~ COMMENT? ~ line_terminator? }
inner_program = { line* }
program = { SOI ~ inner_program ~ COMMENT? ~ EOI }

// (duplicate simple_command definition removed)
